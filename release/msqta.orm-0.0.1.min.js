(function( window ) {
var MSQTA = MSQTA || {};
/***************************************/
/***************************************/
MSQTA._rr = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
MSQTA._ss = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
if( !MSQTA._ss.READ_WRITE || !MSQTA._ss.READ_ONLY ) {
	MSQTA._ss.READ_WRITE = 'readwrite';
	MSQTA._ss.READ_ONLY = 'readonly';
}
MSQTA._tt = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
/***************************************/
/***************************************/

/***************************************/
/***************************************/
MSQTA._ii = {
	a: function() {
	},
	
	b: function(){},
	
	ll: 2 * 1024 * 1024,
/***************************************/
	c: function( dataType ) {
		if( dataType === 'object' || dataType === 'array' ) {
			return this.d;
		}
		if( dataType === 'datetime' ) {
			return this.h;
		}
		if( dataType === 'date' ) {
			return this.e;
		} 
		if( dataType === 'time' ) {
			return this.g;
		} 
		if( dataType === 'boolean' ) {
			return this.i;
		} 
		return this.j;
	},
	
	d: function( value ) {
		return JSON.parse( value );
	},
	
	e: function( value ) {
		var d = value.split( '-' );
		return new Date( d[0], d[1]-1, d[2], 0, 0, 0, 0 );
	},
	
	g: function( value ) {
		var d = new Date(),
			t = value.split( ':' );
		
		d.setHours( t[0] );
		d.setMinutes( t[1] );
		d.setSeconds( t[2] );
		
		return d;
	},
	
	h: function( value ) {
		var d = value.split( ' ' ),
			d1 = d[0].split( '-' ),
			d2 = d[1].split( ':' );
		
		return new Date( d1[0], d1[1]-1, d1[2], d2[0], d2[1], d2[2], 0 );
	},
	
	i: function( value ) {
		return !!value;
	},
	
	j: function( value ) {
		return value;
	},
/***************************************/	
	qq: [ 'batch', 'destroy' ],
	pp: [ 'del', 'destroy', 'empty', 'get', 'getAll', 'getWithLike', 'getByCallback', 'getByIndex', 'getByIndexWithRange', 'put', 'set' ],
	
	k: function( Schema ) {
		var pp = this.pp,
			a = this.a,
			i, l;
		
		for( i = 0, l = pp.length; i < l; i++ ) {
			Schema[pp[i]] = a;
		}
	},
	
	l: function( ORM ) {
		var qq = this.qq,
			pp = this.pp, schemaName, Schema, schemas,
			a = this.a,
			i, l;
		
		for( i = 0, l = qq.length; i < l; i++ ) {
			ORM[qq[i]] = a;
		}
		schemas = ORM._vv;
		for( schemaName in schemas ) {
			Schema = schemas[schemaName];
			for( i = 0, l = pp.length; i < l; i++ ) {
				Schema[pp[i]] = a;
			}
		}
	},
/***************************************/
/***************************************/
	m: function( prefered ) {
		prefered = prefered.toLowerCase();
		
		if( prefered === 'websql' ) {
			if( window.openDatabase ) {
				return MSQTA._a2.b6;
			}
		} else if( prefered === 'indexeddb' ) {
			if( MSQTA._rr ) {
				return MSQTA._a2.b5;
			}
		}
		
		if( window.openDatabase ) {
			return MSQTA._a2.b6;
		} else if( MSQTA._rr ) {
			return MSQTA._a2.b5;
		}
	},

	n: function( setup ) {
		var ORM = setup.ORM,
			schemaPrototype = setup.schemaPrototype,
			implementation = setup.implementation,
			schemaDefinition = setup.schemaDefinition,
			args = setup.args,
			options = {},
			schema;

		if( !ORM ) {
			throw Error( 'MSQTA-ORM!' );
		}

		if( typeof args[1] === 'function' ) {
			options.callback = args[1];
			options.context = args[2] || window;
		} else if( typeof args[1] === 'object' ) {
			options = args[1];
		}
		
		MSQTA._a9.prototype = schemaPrototype;
		schema = new MSQTA._a9( ORM, schemaDefinition, options );
		
		// stole methods
		schema._r = MSQTA._ii.p;
		schema._q = MSQTA._ii.o;
		
		schema._b4 = implementation;
		schema._d5();
		
		return schema;
	},
/***************************************/
/** STOLED METHODS BY THE SCHEMAS PROTOTYPES **/
/***************************************/
	o: function( fieldName, fieldValue ) {
		var schemaFields = this._a4,
			schemaName = this._a3,
			fieldData = schemaFields[fieldName];
		
		if( !fieldData ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		return fieldData.cc( fieldValue, fieldData.bb );
	},
	
	mm: {
		string: 'TEXT',
		integer: 'INTEGER',
		object: 'TEXT',
		array: 'TEXT',
		date: 'DATE',
		time: 'TIME',
		datetime: 'DATETIME',
		float: 'REAL',
		boolean: 'INTEGER'
	},
	
	nn: {
		string: '',
		integer: 0,
		object: '{}',
		array: '[]',
		date: '0000-00-00',
		time: '00:00:00',
		datetime: '0000-00-00 00:00:00',
		float: 0,
		boolean: 0
	},
	
	oo: {
		string: "",
		int: 0,
		integer: 0,
		text: "",
		object: {},
		array: [],
		date: new Date( 0, 0, 0 ),
		time: new Date( 0, 0, 0 ),
		datetime: new Date( 0, 0, 0 ),
		float: 0,
		boolean: false
	},
	
	p: function( fieldName ) {
		var implementation = this._b4,
			dataTypes = MSQTA._ii.mm,
			dataTypeZeros = implementation === 'webSQL' ? MSQTA._ii.nn : MSQTA._ii.oo,
		
			schemaName = this._a3,
			databaseName = this._a2._a3,
			fieldDefinition = this._a4[fieldName],
			schemaFieldData,
			// integer || string || ...
			type = fieldDefinition.type,
			realDataType = dataTypes[type],
			allowNull = fieldDefinition.allowNull;

		if( !realDataType ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		// now reset the schema for a more easy usage
		schemaFieldData = this._a4[fieldName];
		// used when no values are specified to this col
		schemaFieldData.bb = allowNull ? ( implementation === 'webSQL' ? null : null ) : dataTypeZeros[type];
		// cc function
		schemaFieldData.cc = implementation === 'webSQL' ? MSQTA._ii.jj.s( type ) : MSQTA._ii.kk.s( type );
		// need it is the ff type is object, date, etc (on indexedDB implementation this not needed it)
		schemaFieldData.dd = MSQTA._ii.c( type );
		schemaFieldData.ee = type === 'date' || type === 'time' || type === 'datetime';
		
		if( implementation === 'webSQL' ) {
			schemaFieldData.ff = type;
			schemaFieldData.gg = realDataType + ( allowNull ? ' NULL' : '' );
			schemaFieldData.hh = type === 'object' || type === 'array';
		
		}
	}
};
/***************************************/
MSQTA._ii.jj = {
	
	s: function( dataType ) {
		if( dataType === 'string' || dataType === 'text' ) {
			return this.t;
		}
		if( dataType === 'int' || dataType === 'integer'  || dataType === 'float' ) {
			return this.u;
		}
		if( dataType === 'object' || dataType === 'array' ) {
			return this.y;
		}
		if( dataType === 'date' ) {
			return this.v;
		} 
		if( dataType === 'time' ) {
			return this.w;
		} 
		if( dataType === 'datetime' ) {
			return this.x;
		} 
		if( dataType === 'boolean' ) {
			return this.z;
		}
	},
	
	t: function( value, onZero ) {
		return value || onZero;
	},
	
	u: function( value, onZero ) {
		value -= 0;
		return !value ? onZero : value;
	},
	
	v: function( value, onZero ) {
		var m, d;
		if( value instanceof Date && +value >= 0 ) {
			m = value.getMonth() + 1;
			d = value.getDate();
			return value.getFullYear() + '-' + ( m < 10 ? '0' + m : m ) + '-' + ( d < 10 ? '0' + d : d );
		} 
		m = /^(\d{4}-\d{2}-\d{2})(?: \d{2}:\d{2}(?::\d{2}))?$/.exec( value );
		if( !m ) {
			return onZero;
		}
		return m[1];
	},
	
	w: function( value, onZero ) {
		if( value instanceof Date && +value >= 0 ) {
			return value.toTimeString().substring( 0, 8 );
		}
		var m = /^(?:\d{4}-\d{2}-\d{2} )?(\d{2}:\d{2})(:\d{2})?$/.exec( value );
		if( !m ) {
			return onZero;
		}
		return m[1] + ( m[2] || ':00' );
	},
	
	x: function( value, onZero ) {
		var m, d;
		if( value instanceof Date && +value >= 0 ) {
			m = value.getMonth() + 1;
			d = value.getDate();
			return value.getFullYear() + '-' + ( m < 10 ? '0' + m : m ) + '-' + ( d < 10 ? '0' + d : d ) + ' ' + value.toTimeString().substring( 0, 8 );
		}
		m = /^(\d{4}-\d{2}-\d{2})(?: |T)(\d{2}:\d{2})(?:(:\d{2})[^Z]+Z|(:\d{2}))?$/.exec( value );
		if( !m ) {
			return onZero;
		}
		return m[1] + ' ' + m[2] + ( m[3] || m[4] || ':00' );
	},
	
	y: function( value, onZero ) {
		if( typeof value === 'undefined' ) {
			return onZero;
		}
		
		if( typeof value !== 'object' ) {
			// is null or bb
			if( !value ) {
				return onZero;
			}
			if( typeof value === 'string' ) {
				return "'" + value + "'";
			}
			// number
			return value;
		}
		
		try {
			return JSON.stringify( value );
		} catch( e ) {
			return onZero;
		}
	},
	
	z: function( value, onZero ) {		
		if( typeof value === 'string' ) {
			value = value.toLowerCase();
			if( value === 'true' || value === '1' ) {
				return 1;
			} 
			if( value === 'false' || value === '0' ) {
				return 0;
			}
			return onZero;
		}
		if( value === 1 ) {
			return 1;
		}
		if( value === 0 ) {
			return 0;
		}
		
		return onZero;
	},
	
	aa: function( value ) {
		return value;
	}
};
/***************************************/
MSQTA._ii.kk = {
	
	s: function( dataType ) {
		if( dataType === 'string' || dataType === 'text' ) {
			return this.t;
		}
		if( dataType === 'int' || dataType === 'integer'  || dataType === 'float' ) {
			return this.u;
		}
		if( dataType === 'object' || dataType === 'array' ) {
			return this.y;
		}
		if( dataType === 'date' ) {
			return this.v;
		} 
		if( dataType === 'time' ) {
			return this.w;
		} 
		if( dataType === 'datetime' ) {
			return this.x;
		} 
		if( dataType === 'boolean' ) {
			return this.z;
		}
	},
	
	t: function( value, onZero ) {
		return value ? value + '' : onZero;
	},
	
	u: function( value, onZero ) {
		value -= 0;
		return !value ? onZero : value;
	},
	
	v: function( value, onZero ) {
		var m, d;
		if( value instanceof Date && !isNaN( value-0 ) ) {
			value.setHours( 0 );
			value.setMinutes( 0 );
			value.setSeconds( 0 );
			value.setMilliseconds( 0 );
			return value;
		} 
		m = /^(\d{4}-\d{2}-\d{2})(?: \d{2}:\d{2}(?::\d{2}))?$/.exec( value );
		if( !m ) {
			return onZero;
		}
		m = m[1].split( '-' );
		return new Date( m[0], m[1]-1, m[2], 0, 0, 0, 0 );
	},
	
	w: function( value, onZero ) {
		if( value instanceof Date && !isNaN( value-0 ) ) {
			return value;
		}
		var m = /^(\d{4}-\d{2}-\d{2} )?(\d{2}:\d{2})(:\d{2})?$/.exec( value );
		if( !m ) {
			return onZero;
		}
		var y, hourAndMinutes, seconds;
		if( !m[1] ) {
			y = new Date();
			y = [ y.getFullYear(), y.getMonth(), y.getDate() ];
		} else {
			y = m[1].split( '-' );
			// decrease month number
			y[1] = y[1]-1;
		}
		hourAndMinutes = m[2].split( ':' );
		seconds = m[3] || 0;
		return new Date( y[0], y[1], y[2], hourAndMinutes[0], hourAndMinutes[1], seconds, 0 );
	},
	
	x: function( value, onZero ) {
		var m, d;
		if( value instanceof Date && !isNaN( value-0 ) ) {
			return value;
		}
		m = /^(\d{4}-\d{2}-\d{2})(?: |T)(\d{2}:\d{2})(?::(\d{2})[^Z]+Z|:(\d{2}))?$/.exec( value );
		if( !m ) {
			return onZero;
		}
		var y, hourAndMinutes, seconds;
		y = m[1].split( '-' );
		hourAndMinutes = m[2].split( ':' );
		seconds = m[3] || m[4] || 0;
		return new Date( y[0], y[1]-1, y[2], hourAndMinutes[0], hourAndMinutes[1], seconds, 0 );
	},
	
	y: function( value, onZero ) {
		if( typeof value === 'undefined' ) {
			return onZero;
		}
		
		if( typeof value !== 'object' ) {
			// is null or bb
			if( !value ) {
				return onZero;
			}
			if( typeof value === 'string' ) {
				return "'" + value + "'";
			}
			// number
			return value;
		}
		
		return value;
	},
	
	z: function( value, onZero ) {		
		if( typeof value === 'string' ) {
			value = value.toLowerCase();
			if( value === 'true' || value === '1' ) {
				return true;
			} 
			if( value === 'false' || value === '0' ) {
				return false;
			}
			return onZero;
		}
		if( value === 1 ) {
			return true;
		}
		if( value === 0 ) {
			return false;
		}
		
		return onZero;
	},
	
	aa: function( value ) {
		return value;
	}
};
/***************************************/
/***************************************/
MSQTA.ORM = function( settings, callback, context ) {
	if( typeof settings === 'string' ) {
		settings = { name: settings };
	}
	if( !settings.name ) {
		throw Error( 'MSQTA-ORM!' );
	}
	
	settings.callback = typeof callback === 'function' ? callback : MSQTA._ii.b;
	settings.context = context || window;
	
	MSQTA._a2.prototype = MSQTA._ii.m( settings.prefered || '' );
	return new MSQTA._a2( settings );
};
/***************************************/
MSQTA._a2 = function( settings ) {
	var databaseName = this._a3 = settings.name;
	
	
	this.forceDestroy = settings.forceDestroy;
	
	// put here all g1 to be executed
	this._uu = [];
	this._vv = {};
	// used when multiple call to batch function are maded
	this._ww = [];

	// this.Schema is the function that create schemas from
	// this particulaty database, this.Schema._a2 is there
	// reference to this instantice for each schema that is created
	this.Schema._a2 = this;

	this._xx = true;
	// until this process is alive, we cannot init the schemas
	// so any call to this.schema() will put in this stack
	this._yy = [];
		
	this._zz = settings.callback;
	this._a1 = settings.context;

	// start the shit
	if( this.forceDestroy ) {
		
		this._c4( this._b7, this );
		
	} else {
		this._b7();
	}
};
/***************************************/
/***************************************/
MSQTA._a9 = function( ORM, schemaDefinition, options ) {
	
	var databaseName = ORM._a3,
		schemaName = schemaDefinition.name;
	
	if( ORM._vv[schemaName] && !options.forceDestroy ) {
		throw Error( 'MSQTA-ORM!' );
	}
	
	var schemaFields = schemaDefinition.fields;
	if( typeof schemaFields !== 'object' || !Object.keys( schemaFields ).length ) {
		throw Error( 'MSQTA-ORM!' );
	}
	
	var pk = schemaDefinition.primaryKey;
	// check if pk refers to a exisitnet colmun
	if( !pk || ( pk && !schemaFields[pk] ) ) {
		throw Error( 'MSQTA-ORM!' );
	}
	if( schemaFields[pk].type !== 'integer' ) {
		throw Error( 'MSQTA-ORM!' );
	}
	// force null values on the primary key, to get working the auto_increment
	schemaFields[pk].allowNull = true;
	
	var fieldName, fieldData,
		schemaIndexes = [],
		schemaUniques = [];
	// get the indexes
	for( fieldName in schemaFields ) {
		fieldData = schemaFields[fieldName];
		if( fieldData.index ) {
			if( !/^(integer|float|string|date|time|datetime)$/.test( fieldData.type ) ) {
				throw Error( 'MSQTA-ORM!' );
			}
			schemaIndexes.push( fieldName );
		} else {
			fieldData.index = false;
		}
		if( fieldData.unique ) {
			// put also on indexes
			if( schemaIndexes.indexOf( fieldName ) === -1 ) {
				schemaIndexes.push( fieldName );
			}
			schemaUniques.push( fieldName );
		} else {
			fieldData.unique = false;
		}
	}
	
	ORM._vv[schemaName] = this;

	this._a2 = ORM;
	
	this._a3 = schemaName;
	this._a4 = schemaFields;
	this._a5 = schemaIndexes;
	this._a6 = schemaUniques;
	this._a7 = pk;
	this._a8 = Object.keys( schemaFields );
	// options
	this.forceDestroy = options.forceDestroy;
	this.forceEmpty = this.forceDestroy ? false : options.forceEmpty;
	this._zz = typeof options.callback === 'function' ? options.callback : MSQTA._ii.b;
	this._a1 = options.context || window;
};
MSQTA._a2.b5 = {
	
	Schema: function( schemaDefinition ) {
		return MSQTA._ii.n( { 
			ORM: this.constructor._a2,
			schemaPrototype: MSQTA._a9.b5,
			schemaDefinition: schemaDefinition,
			implementation: 'indexedDB',
			args: arguments
		} );
	},
	
	_b7: function() {
		
		
		var self = this,
			databaseName = this._a3,
			// __msqta__ is the place that all the know databases information are stores
			// we need this to take track of different version numbers of all user databases
			req = MSQTA._rr.open( '__msqta__', 1 );
		
		// create the __msqta__ schema (this only ocucrrs in the first run, latter onupgradeneeded never agina will be called)
		req.onupgradeneeded = function( e ) {
			var db = e.target.result,
				tableDatabases;
			
			
			
			tableDatabases = db.createObjectStore( 'databases', { keyPath: 'id', autoIncrement: true } );
			tableDatabases.createIndex( 'name', 'name', { unique: true } );
			
			// store the records when we need a complete update a schema
			db.createObjectStore( 'dump' );
		};
		
		// now figure out the user database is a new one and get its current branch (version number)
		req.onsuccess = function( e ) {
			var db = e.target.result,
				transaction = db.transaction( [ 'databases' ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( 'databases' );

			// get the user database information in __msqta__
			objectStore.index( 'name' ).get( databaseName ).onsuccess = function( e ) {
				var userDatabaseRecord = e.target.result;
		
				// first run
				if( !userDatabaseRecord ) {
					
					
					self._currentBranch = 0;
					
					objectStore.add( { name: databaseName, branch: 0, schemas: {} } ).onsuccess = function( e ) {
						db.close();
						self._d5();
					};
				
				// not need to create the userDatabaseRecord
				} else {
					db.close();
					var currentBranch = userDatabaseRecord.branch;

					
					// get the current branch
					self._currentBranch = currentBranch;
					
					self._d5();
				}
			};
		};
		
		// fail to open database
		req.onerror = function( e ) {
			// trigger event
			this._zz.call( this._a1, null );
		};
	},
	
	_d5: function() {
		
		// trigger event
		this._zz.call( this._a1, true );
		// trigger the schemas process
		this._c1();
	},
	
	_c4: function( callback, context ) {
		var self = this,
			databaseName = this._a3,
			req = MSQTA._rr.deleteDatabase( databaseName );
		
		req.onsuccess = function( e ) {
			// ahora debo borrar toda esa information de __msqta__.databases
			req = MSQTA._rr.open( '__msqta__' );
			req.onsuccess = function( e ) {
				var db = e.target.result,
					transaction = db.transaction( [ 'databases' ], MSQTA._ss.READ_WRITE ),
					objectStore = transaction.objectStore( 'databases' );
				
				objectStore.index( 'name' ).get( databaseName ).onsuccess = function( e ) {
					var userDatabaseRecord = e.target.result;
					objectStore.delete( userDatabaseRecord.id ).onsuccess = function( e ) {
						db.close();
						
						MSQTA._ii.l( self );
						
						callback.call( context || window, true );
					};
				};
			};
		};
		
		req.onerror = function( e ) {
			callback.call( context || window, false );
		};
	},
/*********************/
/**** schema treatmentes functions **/
/********************/
	_b9: function( Schema ) {
		this._yy.push( Schema );
		if( !this._xx ) {
			this._c1();
		}
	},
	
	_c1: function() {
		var self = this,
			databaseName = this._a3,
			req;
		
		if( this._yy.length ) {			
			req = MSQTA._rr.open( '__msqta__', 1 );
			req.onsuccess = function( e ) {
				var db = e.target.result,
					transaction = db.transaction( [ 'databases' ], MSQTA._ss.READ_WRITE ),
					objectStore = transaction.objectStore( 'databases' );
				
				// we need to get the user database data to detect schemas changes
				objectStore.index( 'name' ).get( databaseName ).onsuccess = function( e ) {
					// this is current schema and branch
					var userDatabaseRecord = e.target.result;
					self._h7( db, objectStore, userDatabaseRecord );
				};
			};
			
			req.onerror = this._h9;
			
		} else {
			this._c2();
		}
	},

	_h7: function( db, objectStore, userDatabaseRecord ) {
		var self = this,
			databaseName = this._a3,
			// an instance of MSQTA._a9,
			Schema = this._yy.shift(),
			schemaName = Schema._a3,
			// this is from __msqta__.databases[databaseName]
			registeredSchemaDefinition = userDatabaseRecord.schemas[schemaName],
			currentSchemaDefinition = { fields: Schema._a4, primaryKey: Schema._a7 };
		
		// save a reference
		this._currentSchema = Schema;

		// a new one schema
		if( !registeredSchemaDefinition ) {
			this._h8( objectStore, userDatabaseRecord );
			
			// close the __msqta__ database
			db.close();
			
			// now create the schema in [this._a3]
			this._e1();
			
		// destroy directly the shcema
		} else if( Schema.forceDestroy ) {
			
			this._e4( this._e7 );
		
		} else if( Schema.forceEmpty ) {
			
			this._e8();

		// else check for schema changes
		} else {
			
			
			// close the __msqta__ database
			db.close();
			
			if( this._d9( registeredSchemaDefinition, currentSchemaDefinition ) ) {
				
				
				this._e2();
				
			} else {
				
				
				this._i2();
			}
		}
	},
	
	_d9: function( registeredSchemaDefinition, currentSchemaDefinition ) {
		// check for schema changes
		var isNewSchema = false,
			registeredFields = registeredSchemaDefinition.fields,
			currentFields = currentSchemaDefinition.fields,
			registeredFieldData, currentFieldData;
		
		for( fieldName in registeredFields ) {
			registeredFieldData = registeredFields[fieldName];
			currentFieldData = currentFields[fieldName];
			
			// the fieldName is not more present in the new schecma
			if( !currentFieldData ||
			// same fieldName but different structure tyoe	
			registeredFieldData.type !== currentFieldData.type ||
			// index checks
			registeredFieldData.index !== currentFieldData.index ||
			registeredFieldData.unique !== currentFieldData.unique ) {
				isNewSchema = true;
				break;
			}
		}

		var registeredPK = registeredSchemaDefinition.primaryKey,
			currentPK = currentSchemaDefinition.primaryKey;
		// check for schema changes at primaryKey level
		if( !isNewSchema ) {
			// chaging/droping the primaryKey required a new schema too
			if( ( registeredPK && ( !currentPK || registeredPK !== currentPK ) ) ||
			// previoulsy there is not a primary key, but now yes
			( !registeredPK && currentPK ) ) {
				isNewSchema = true;
			}
		}
		
		return isNewSchema;
	},
	
	_h8: function( objectStore, userDatabaseRecord ) {
		var Schema = this._currentSchema,
			schemaName = Schema._a3,
			primaryKey = Schema._a7,
			schemaKeepTrack = Schema._b3;
		
		userDatabaseRecord.schemas[schemaName] = {
			fields: schemaKeepTrack,
			primaryKey: primaryKey
		};
		// save the schema data in databaseData.schemas
		req = objectStore.put( userDatabaseRecord );

		return req;
	},
	
	_e1: function() {
		var self = this,
			Schema = this._currentSchema,
			databaseName = this._a3,
			schemaName = Schema._a3,
			req = this._i4();
		
		req.onupgradeneeded = function( e ) {
			var db = e.target.result;
			
			
			
			self._i1( db );
		};
		
		req.onsuccess = function( e ) {
			var db = e.target.result;
			db.close();
			
			self._i3( self._i2, self );
		};
		
		req.onerror = this._h9;
	},
	
	_e2: function() {
		var self = this,
			req = MSQTA._rr.open( '__msqta__', 1 );
		
		// cleaning any shit on dump (this is only happens when the user
		// shutdown the browser when this process was running for example)
		req.onsuccess = function( e ) {
			var db = e.target.result,
				transaction = db.transaction( [ 'dump' ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( 'dump' );
			
			objectStore.clear().onsuccess = function( e ) {
				db.close();
				self._e3();
			};
		};
		
		req.onerror = this._h9;
	},

	_e3: function() {
		var self = this,
			Schema = this._currentSchema,
			schemaName = Schema._a3,
			databaseName = this._a3,
			key = 0, isAdvance = false,
			msqtaDB, userDatabase;
		
		
		
		var getCursor = function() {
			var req = self._i5();
			req.onsuccess = function( e ) {
				userDatabase = e.target.result;
				var transaction = userDatabase.transaction( [ schemaName ], MSQTA._ss.READ_ONLY ),
					objectStore = transaction.objectStore( schemaName );
				
				objectStore.openCursor().onsuccess = getRecord;
			};
			
			req.onerror = this._h9;
		};
		
		var getRecord = function( e ) {
			var cursor = e.target.result;
			if( cursor ) {
				// cursor.advance() has been triggered
				if( isAdvance ) {
					saveRecord( cursor.value );
					isAdvance = false;
					userDatabase.close();
				// initial case
				} else if( key === 0 ) {
					saveRecord( cursor.value );
					key++;
					userDatabase.close();
				} else {
					cursor.advance( key );
					key++;
					isAdvance = true;
				}
			} else {
				userDatabase.close();
				done();
			}
		};
		
		var saveRecord = function( record ) {
			var req = MSQTA._rr.open( '__msqta__', 1 );
			req.onsuccess = function( e ) {
				msqtaDB = e.target.result;
				var transaction = msqtaDB.transaction( [ 'dump' ], MSQTA._ss.READ_WRITE ),
					objectStore = transaction.objectStore( 'dump' );
			
				
				objectStore.add( record, key ).onsuccess = nextRecord;
			};
			
			req.onerror = this._h9;
		};
		
		var nextRecord = function( e ) {
			msqtaDB.close();
			getCursor();
		};
		
		var done = function() {
			self._e4( self._e5 );
		};
		
		// start
		getCursor();
	},
	
	_e4: function( next ) {
		var self = this,
			Schema = this._currentSchema,
			schemaName = Schema._a3,
			databaseName = this._a3,
			req = this._i4();

		req.onupgradeneeded = function( e ) {
			var db = e.target.result;
			
			
			
			// first delete the schema
			db.deleteObjectStore( schemaName );
			
			// now process to create the schema with its new schema data
			self._i1( db );
		};
		
		req.onsuccess = function( e ) {
			var db = e.target.result;
			db.close();
			
			
			self._i3( next, self );
		};
		
		req.onerror = this._h9;
	},
	
	_e5: function() {
		var self = this,
			Schema = this._currentSchema,
			schemaName = Schema._a3,
			schemaFields = Schema._a4,
			databaseName = this._a3,
			msqtaDB, userDatabase, isAdvance = false, key = 0;
		
		
		
		var getCursor = function() {
			var req = MSQTA._rr.open( '__msqta__', 1 );
			req.onsuccess = function( e ) {
				msqtaDB = e.target.result;
				var transaction = msqtaDB.transaction( [ 'dump' ], MSQTA._ss.READ_ONLY ),
					objectStore = transaction.objectStore( 'dump' );
				
				objectStore.openCursor().onsuccess = getRecord;
			};
			
			req.onerror = this._h9;
		};
		
		var getRecord = function( e ) {
			var cursor = e.target.result;
			if( cursor ) {
				// cursor.advance() has been triggered
				if( isAdvance ) {
					saveRecord( cursor.value );
					isAdvance = false;
					msqtaDB.close();
				// initial case
				} else if( key === 0 ) {
					saveRecord( cursor.value );
					key++;
					msqtaDB.close();
				} else {
					cursor.advance( key );
					key++;
					isAdvance = true;
				}
			} else {
				msqtaDB.close();
				done();
			}
		};
		
		var saveRecord = function( record ) {
			var req = self._i5();
			req.onsuccess = function( e ) {
				userDatabase = e.target.result;
				var transaction = userDatabase.transaction( [ schemaName ], MSQTA._ss.READ_WRITE ),
					objectStore = transaction.objectStore( schemaName ),
					fieldName, schemaField, req;
			
				for( fieldName in record ) {
					schemaField = schemaFields[fieldName];
					if( schemaField ) {
						record[fieldName] = schemaField.cc( record[fieldName], schemaField.bb );
					} else {
						delete record[fieldName];
					}
				}
				
				
				req = objectStore.put( record );
				req.onsuccess = nextRecord;
				req.onerror = nextRecord;
			};
			
			req.onerror = this._h9;
		};
		
		var nextRecord = function( e ) {
			userDatabase.close();
			getCursor();
		};
		
		var done = function() {
			self._e6();
		};
		
		// start
		getCursor();
	},
	
	_e6: function() {
		var self = this,
			databaseName = this._a3,
			req;

		req = MSQTA._rr.open( '__msqta__', 1 );
		req.onsuccess = function( e ) {
			var db = e.target.result,
				transaction = db.transaction( [ 'dump' ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( 'dump' );
			
			
			objectStore.clear().onsuccess = function( e ) {
				db.close();
				
				self._e7();
			};
		};
		
		req.onerror = this._h9;
	},
	
	_e7: function() {
		var self = this,
			databaseName = this._a3,
			Schema = this._currentSchema,
			schemaName = Schema._a3,
			req;
	
		req = MSQTA._rr.open( '__msqta__', 1 );
		req.onsuccess = function( e ) {
			var db = e.target.result,
				transaction = db.transaction( [ 'databases' ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( 'databases' );
			
			objectStore.index( 'name' ).get( databaseName ).onsuccess = function( e ) {
				var userDatabaseRecord = e.target.result,
					req;
				
				
				// update the shchema information
				req = self._h8( objectStore, userDatabaseRecord );
				req.onsuccess = function( e ) {
					db.close();
					self._e9();
				};
			};
		};
		
		req.onerror = this._h9;
	},
	
	_e8: function() {
		var self = this,
			databaseName = this._a3,
			Schema = this._currentSchema,
			schemaName = Schema._a3,
			req;

		req = this._i5();
		req.onsuccess = function( e ) {
			var db = e.target.result,
				transaction = db.transaction( [ schemaName ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( schemaName );
			
			// truncate schema, this happend the the "forceEmpty" flag is actived
			objectStore.clear().onsuccess = function( e ) {
				self._e9();
			};
		};
		
		req.onerror = this._h9;
	},
		
	_e9: function() {
		
		// done
		this._i2();
	},
	
	_h9: function() {
		this._i2( false );
	},
	
	/**
	* this is called from _e1 and from _e2 (after deleting its current schema)
	*/
	_i1: function( db ) {
		var Schema = this._currentSchema,
			schemaFields = Schema._a4,
			schemaName = Schema._a3,
			primaryKey = Schema._a7,
			fieldName, fieldData, isUnique,
			objectStore;
		
		
		objectStore = db.createObjectStore( schemaName, { keyPath: primaryKey, autoIncrement: true } );
		
		// create the indexes
		for( fieldName in schemaFields ) {
			fieldData = schemaFields[fieldName];
			if( fieldData.index ) {
				isUnique = fieldData.unique;
				
				objectStore.createIndex( fieldName, fieldName, isUnique ? { unique: true } : {} );
			}
		}
	},
	
	_i2: function( statusCode ) {
		var Schema = this._currentSchema,
			callback = Schema._zz,
			context = Schema._a1;
		
		// get back to the user
		callback.call( context, typeof statusCode === 'undefined' ? true: statusCode );
		// clean
		delete Schema._zz;
		delete Schema._a1;
		delete this._currentSchema;
		
		// continue with more shit
		this._c1();
	},
	
	_c2: function() {
		// done mothefucker
		this._xx = false;
	},
/*********************/
/**** helpers functions **/
/********************/
	_i3: function( callback, context ) {
		var self = this,
			databaseName = this._a3,
			newBranch = this._currentBranch,
			req;
		
		req = MSQTA._rr.open( '__msqta__', 1 );
		req.onsuccess = function( e ) {
			var db = e.target.result,
				transaction = db.transaction( [ 'databases' ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( 'databases' );
		
			objectStore.index( 'name' ).get( databaseName ).onsuccess = function( e ) {
				var userDatabaseRecord = e.target.result;
				
				
				
				// update branch
				userDatabaseRecord.branch = newBranch;
				objectStore.put( userDatabaseRecord );
				
				db.close();
				
				if( callback ) {
					callback.call( context || window );
				}
			};
		};
	},
	/**
	* this method will cause to trigger onupgradeneeded event
	*/
	_i4: function() {
		var databaseName = this._a3,
			nextBranch = this._currentBranch + 1;
		
		
		// keep track
		this._currentBranch = nextBranch;
		
		return MSQTA._rr.open( databaseName, nextBranch );	
	},
	
	/**
	* just open the database at the current branch
	*/
	_i5: function() {
		var databaseName = this._a3,
			currentBranch = this._currentBranch;
		
		
		
		return MSQTA._rr.open( databaseName, currentBranch );	
	},
	
	_i6: function( queryData ) {
		if( !queryData.callback ) {
			queryData.callback = MSQTA._ii.b;
		}
		if( !queryData.context ) {
			queryData.context = window;
		}
		
		// save the entred g1
		this._uu.push( queryData );
		
		if( this._b2 ) {
			return;
		}
		this._b2 = true;
		
		this._i7();
	},
	
	_i7: function() {
		var self = this,
			q = this._uu.shift(),
			databaseName = this._a3,
			schemaName = q.schema,
			type = q.type,
			req;

		// especial case
		if( type === 'destroy' ) {
			this._f3( q );
		
		} else {
			req = this._i5(); 
			req.onsuccess = function( e ) {
				var db = e.target.result,
					type = q.type,
					transaction = db.transaction( [ schemaName ], MSQTA._ss.READ_WRITE );
					objectStore = transaction.objectStore( schemaName );
				
				// keep augmenting q (queryData)
				q.objectStore = objectStore;
				q.database = db;
				
				
			
				self['_' + type]( q );
			};
		}
	},
	
	_d1: function() {
		this._b2 = false;
		if( this._uu.length ) {
			this._i7();
		}
	},
	
	// this one is called when _put, _set, _del, _empty finish
	_i8: function( queryData, results ) {
		queryData.database.close();
		// come back to the user
		queryData.callback.call( queryData.context, results );
		// keep executing more queries
		this._d1();
	},
	
	_put: function( queryData ) {
		var self = this,
			objectStore = queryData.objectStore,
			datas = queryData.data,
			currentIndex = 0,
			totalQueries = datas.length;
		
		var next = function( lastID ) {
			if( currentIndex === totalQueries ) {
				self._i8( queryData, lastID );
				
			} else {
				// insert the data
				process();
				currentIndex++;
			}
		};
		
		var process = function() {
			var data = datas[currentIndex],
				req = objectStore.add( data );
			
			req.onsuccess = function( e ) {
				// the lastID
				next( e.target.result );
			};
			
			req.onerror = function( e ) {
				next( false );
			};
		};
		
		next();
	},
	
	_set: function( queryData ) {
		var self = this,
			objectStore = queryData.objectStore,
			datas = queryData.data,
			indexes = queryData.indexes,
			pk = queryData.primaryKey,
		
			rowsAffected = 0,
			
			currentIndex = 0, totalQueries = datas.length;
		
		var next = function() {
			if( currentIndex === totalQueries ) {
				self._i8( queryData, rowsAffected );
			
			} else {
				// update the data
				process();
				currentIndex++;
			}
		};
		
		var process = function() {
			var data = datas[currentIndex],
				setData = data.data,
				target = data.target,
				targetPk = target[pk], fieldName,
				colsCount = Object.keys( target ).length;
			
			if( targetPk ) {
				objectStore.get( targetPk ).onsuccess = function( e ) {
					var record = e.target.result,
						req;
					if( record ) {
						// update the record
						for( fieldName in setData ) {
							record[fieldName] = setData[fieldName];
						}
					
						req = objectStore.put( record );
						req.onsuccess = function( e ) {
							if( e.target.result ) {
								rowsAffected++;
							}
							next();
						};
						req.onerror = function( e ) {
							next( false );
						};
					} else {
						next();
					}
				};
				
			} else {
				// get all the records, yes all of them!!
				// start iteration
				objectStore.openCursor().onsuccess = function( e ) {
					var cursor = e.target.result;
					if( cursor ) {
						// get the pointed 
						var record = cursor.value,
							match = 0, req;
						// compare
						for( fieldName in target ) {
							if( record[fieldName] === target[fieldName] ) {
								match++;
							}
						}
						// this is pathetic
						if( match === colsCount ) {
							// update the record
							for( fieldName in setData ) {
								record[fieldName] = setData[fieldName];
							}
							
							req = cursor.update( record );
							req.onsuccess = function( e ) {
								if( e.target.result ) {
									rowsAffected++;
								}
								cursor.continue();
							};
							req.onerror = function( e ) {
								cursor.continue();
							};
							
						} else {
							cursor.continue();
						}
						
					// end
					} else {
						next();
					}
				};
			}
		};
		
		next();
	},
	
	_del: function( queryData ) {
		var self = this,
			objectStore = queryData.objectStore,
			datas = queryData.data,
			pk = queryData.primaryKey,
		
			rowsAffected = 0,
		
			currentIndex = 0, totalQueries = datas.length;
		
		var next = function() {
			if( currentIndex === totalQueries ) {
				self._i8( queryData, rowsAffected );
				
			} else {
				// update the data
				process();
				currentIndex++;
			}
		};
		
		var process = function() {
			var data = datas[currentIndex];
			objectStore.delete( data[pk] ).onsuccess = function( e ) {
				if( e.target.result ) {
					rowsAffected++;
				}
				next();
			};
		};
		
		next();
	},
	
	_empty: function( queryData ) {
		var self = this,
			rowsAffected,
			objectStore = queryData.objectStore;
		
		objectStore.count().onsuccess = function( e ) {
			rowsAffected = e.target.result;
			objectStore.clear().onsuccess = function( e ) {
				self._i8( queryData, rowsAffected );
			};
		};
	},
	
	_f3: function( queryData ) {
		var self = this,
			schemaName = queryData.schema,
			req = this._i4();

		// delete the schema from the user database
		req.onupgradeneeded = function( e ) {
			var db = e.target.result;
			
			db.deleteObjectStore( schemaName );
		};
		
		req.onsuccess = function( e ) {
			var db = e.target.result;
			db.close();
			
			// now delete the schema in __msqta__ databases datas
			self._i9( queryData );
		};
	},
	
	_i9: function( queryData ) {
		var self = this,
			databaseName = this._a3,
			schemaName = queryData.schema,
			Schema = this._vv[schemaName],
			req = MSQTA._rr.open( '__msqta__', 1 );
		
		req.onsuccess = function( e ) {
			// delete the schema from the testigo database
			var db = e.target.result,
				transaction = db.transaction( [ 'databases' ], MSQTA._ss.READ_WRITE ),
				objectStore = transaction.objectStore( 'databases' );
		
			objectStore.index( 'name' ).get( databaseName ).onsuccess = function( e ) {
				var databaseData = e.target.result;
				// delete the schema from schemas
				delete databaseData.schemas[schemaName];
	
				objectStore.put( databaseData ).onsuccess = function( e ) {
					// because to delete the schema from the user database we need to trigger
					// and onupgradeneeded on the user database by incremeting its branch
					self._i3( function() {
						queryData.database = db;
						// delete from here too
						delete self._vv[schemaName];
						MSQTA._ii.k( Schema );
						
						this._i8( queryData, true );
					}, self );
				};
			};
		};
	},
/*********************/
/**** public functions **/
/********************/
	batch: function( data, callback, context ) {
		var databaseName = this._a3,
			batchData;
		
		if( !( data instanceof Array ) || !data.length ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( typeof callback !== 'function' ) {
			callback = MSQTA._ii.b;
		}
		if( typeof context !== 'object' ) {
			context = window;
		}
		// agrup params for a better manipulation
		batchData = {
			data: data,
			callback: callback, 
			context: context
		};
		
		if( this._b1 ) {
			// cant continue
			this._ww.push( batchData );
			return;
		}
		this._b1 = true;
		
		// start the process
		this._d2( batchData );
	},
	
	_d2: function( batchData ) {
		var data = batchData.data,
			typeValids = [ 'set', 'put', 'del' ],
			i = 0, l = data.length, t,
			queryData, Schema, type;
		
		for( ; i < l; i++ ) {
			queryData = data[i],
			Schema = queryData.schema;
			if( !( Schema instanceof MSQTA._a9 ) ) {
				throw Error( 'MSQTA-ORM!' );
			}
			type = queryData.type.toLowerCase();
			if( typeValids.indexOf( type ) === -1 ) {
				throw Error( 'MSQTA-ORM!' );
			}

			t = Schema[type]( queryData.data );
			t.callback = MSQTA._ii.b;
			t.context = window;
			this._uu.push( t );
		}
		// the last one will the return point
		t = this._uu[this._uu.length-1];
		t.callback = batchData.callback;
		t.context = batchData.context;
		
		this._b1 = false;

		if( !this._b2 ) {
			this._d1();
		}
	},
	
	destroy: function( callback, context ) {
		if( typeof callback !== 'function' ) {
			callback = MSQTA._ii.a;
		}
		
		this._c4( callback, context );
	}
};
MSQTA._a9.b5 = {
	
	_d5: function() {
		var ORM = this._a2,
			schemaFields = this._a4, fieldName, fieldData,
			schemaKeepTrack = {};

		for( fieldName in schemaFields ) {
			fieldData = schemaFields[fieldName];
			this._r( fieldName );
			// this is one is store in the testigo database to 
			// keep tracking future changes
			schemaKeepTrack[fieldName] = {
				type: fieldData.type,
				index: fieldData.index,
				unique: fieldData.unique
			};
		}
		this._b3 = schemaKeepTrack;
		
		ORM._b9( this );
	},
/***************************************/
	get: function( searchValue, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaFields = this._a4,
			fieldName, fieldMapping = {},
			schemaName = this._a3;
	
		if( !searchValue ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		for( fieldName in schemaFields ) {
			fieldMapping[fieldName] = this._q( fieldName, searchValue );
		}
		
		var filterCallback = function( record, fields, comparator ) {
			for( var fieldName in record ) {
				if( record[fieldName] === comparator[fieldName] ) {
					return true;
				}
			}
			return false;
		};
		
		
		
		this._j1( {
			callback: filterCallback, 
			comparator: fieldMapping,
			fields: null
		}, g4, g5 );
	},
	
	getAll: function( g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3;
		
		var filterCallback = function() {
			return true;
		};
		
		
		
		this._j1( {
			callback: filterCallback, 
			comparator: null,
			fields: null
		}, g4, g5 );
	},

	getWithLike: function( fields, likeData, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaFields = this._a4,
			schemaName = this._a3,
			i, l, fieldName,
			likeType, searchValue;
			
		if( typeof likeData !== 'object' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		likeType = Object.keys( likeData )[0];
		searchValue = likeData[likeType];
		if( !likeType || !searchValue ) {
			throw Error( 'MSQTA-ORM!' );
		}

		if( likeType === 'both' ) {
			searchValue = new RegExp( searchValue, 'i' );
		} else if( likeType === 'start' ) {
			searchValue = new RegExp( '^' + searchValue, 'i' );
		} else if( likeType === 'end' ) {
			searchValue = new RegExp( searchValue + '$', 'i' );
		}
		
		if( !( fields instanceof Array ) ) {
			fields = [ fields ];
		}
		for( i = 0, l = fields.length; i < l; i++ ) {
			fieldName = fields[i];
			if( !schemaFields[fieldName] ) {
				throw Error( 'MSQTA-ORM!' );
			}
		}
		
		var filterCallback = function( record, fields, comparator ) {
			var fieldName,
				i = 0, l = fields.length;
			
			for( ; i < l; i++ ) {
				fieldName = fields[i];
				if( comparator.test( record[fieldName] ) ) {
					return true;
				}
			}
			
			return false;
		};

		
		
		
		this._j1( { 
			callback: filterCallback, 
			comparator: searchValue,
			fields: fields
		}, g4, g5 );
	},
	
	getByCallback: function( filterCallback, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3;
		
		if( typeof filterCallback !== 'function' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		
		
		this._j1( {
			callback: filterCallback,
			comparator: null,
			fields: null
		}, g4, g5 );
	},
	
	_j1: function( filterData, callback, context ) {
		// agriou all params
		var closureData = {
			filterData: filterData,
			callback: callback || MSQTA._ii.b,
			context: context || window,
			self: this
		};
	
		(function( closureData ) {
			var self = closureData.self,
				ORM = self._a2,
				req = ORM._i5(),
				// IDBDatabase object of the user database
				userDatabase,
				databaseName = ORM._a3,
				schemaName = self._a3,
			
				fd = closureData.filterData,
				filterCallback = fd.callback,
				filterComparator = fd.comparator,
				filterFields = fd.fields,
			
				data = [];
			
			req.onsuccess = function( e ) {
				var db = e.target.result,
					transaction = db.transaction( [ schemaName ], MSQTA._ss.READ_ONLY );
					objectStore = transaction.objectStore( schemaName );
			
				userDatabase = db;
				
				objectStore.openCursor().onsuccess = function( e ) {
					var cursor = e.target.result,
						record;
					
					if( cursor ) {
						record = cursor.value;
						if( filterCallback( record, filterFields, filterComparator ) ) {
							data.push( record );
						}
						cursor.continue();
						
					} else {
						// done
						userDatabase.close();
						closureData.callback.call( closureData.context, data );
					}
				};
			};
		})( closureData );
	},
	
	getByIndex: function( fieldName, searchValue, g4, g5 ) {
		var ORM = this._a2,	
			databaseName = ORM._a3,
			schemaName = this._a3,
			indexData = {}, fields = [],
			filterCallback,
			fieldValue, parsedValue, i, l;
		
		if( this._a7 !== fieldName ) {
			if( this._a5.indexOf( fieldName ) === -1 ) {
				throw Error( 'MSQTA-ORM!' );
			}
		}
		
		if( this._a7 === fieldName ) {
			indexData.pk = fieldName;
		} else {
			indexData.index = fieldName;
		}
		
		if( !searchValue ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !( searchValue instanceof Array ) ) {
			searchValue = [ searchValue ];
		}
		
		
		
		if( searchValue.length === 1 ) {
			indexData.keyRange = MSQTA._tt.only( this._q( fieldName, searchValue[0] ) );
			
			this._j2( indexData, g4, g5 );
			
		} else {
			for( i = 0, l = searchValue.length; i < l; i++ ) {
				fieldValue = searchValue[i];
				parsedValue = this._q( fieldName, fieldValue );
				fields.push( parsedValue );
			}
			
			filterCallback = function( record, fields, comparator ) {
				// comparator is the target col used to do the compariosin
				// fields conatins all the value to be compare agains record[comparator] 
				for( var i = 0, l = fields.length; i < l; i++ ) {
					if( fields[i] === record[comparator] ) {
						return true;
					}
				}
				return false;
			};
			
			this._j1( { 
				callback: filterCallback, 
				comparator: indexData.pk || indexData.index,
				fields: fields,
			}, g4, g5 );
		}
	},
	
	getByIndexWithRange: function( fieldName, comparator, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3,
			schemaFields = this._a4,
			validOperators = /^(?:>|<|>=|<=|=)$/, operator,
			indexData = {}, operatorsMapping = {}, operatorsCount, keyRange,
			fieldData = schemaFields[fieldName], fieldValue, parsedValue;
		
		if( this._a7 !== fieldName ) {
			if( this._a5.indexOf( fieldName ) === -1 ) {
				throw Error( 'MSQTA-ORM!' );
			}
		}
		
		if( this._a7 === fieldName ) {
			indexData.pk = fieldName;
		} else {
			indexData.index = fieldName;
		}
		
		// if the field type is date, hence a date object, you can compare equally two date objects
		// so, converting to a comparator of the type >= and <=
		fieldValue = comparator['='];
		if( fieldValue && fieldData.ee ) {
			comparator = {
				'>=': fieldValue,
				'<=': fieldValue
			};
		}
		
		for( operator in comparator ) {
			if( !validOperators.test( operator ) ) {
				throw Error( 'MSQTA-ORM!' );
			}
			fieldValue = comparator[operator];
			parsedValue = this._q( fieldName, fieldValue );
			if( !parsedValue && parsedValue !== fieldData.bb ) {
				throw Error( 'MSQTA-ORM!' );
			}
			operatorsMapping[operator] = parsedValue;
		}
		operatorsCount = Object.keys( operatorsMapping ).length;
		
		if( operatorsCount === 2 ) {
			try {
				if( operatorsMapping['>'] && operatorsMapping['<'] ) {
					keyRange = MSQTA._tt.bound( operatorsMapping['>'], operatorsMapping['<'], true, true );
					
				} else if( operatorsMapping['>='] && operatorsMapping['<='] ) {
					keyRange = MSQTA._tt.bound( operatorsMapping['>='], operatorsMapping['<='] );
				
				} else if( operatorsMapping['>'] && operatorsMapping['<='] ) {
					keyRange = MSQTA._tt.bound( operatorsMapping['>'], operatorsMapping['<='], true, false );
				
				} else {
					keyRange = MSQTA._tt.bound( operatorsMapping['>='], operatorsMapping['<'], false, true );
				}
			} catch( e ) {
				throw Error( 'MSQTA-ORM!' );
			}
			
		} else if( operatorsCount === 1 ) {
			if( operatorsMapping['>'] ) {
				keyRange = MSQTA._tt.lowerBound( operatorsMapping['>'], true );
				
			} else if( operatorsMapping['>='] ) {
				keyRange = MSQTA._tt.lowerBound( operatorsMapping['>='] );
			
			} else if( operatorsMapping['<'] ) {
				keyRange = MSQTA._tt.upperBound( operatorsMapping['<'], true );
			
			} else if( operatorsMapping['<='] ) {
				keyRange = MSQTA._tt.upperBound( operatorsMapping['<='] );
			
			} else {
				keyRange = MSQTA._tt.only( operatorsMapping['='] );
			}
		}
		
		if( !keyRange ) {
			throw Error( 'MSQTA-ORM!' );
		}
		indexData.keyRange = keyRange;
		
		
		
		this._j2( indexData, g4, g5 );
	},
	
	_j2: function( range, callback, context ) {
		// agriou all params
		var closureData = {
			range: range,
			callback: callback || MSQTA._ii.b,
			context: context || window,
			self: this
		};
	
		(function( closureData ) {
			var self = closureData.self,
				ORM = self._a2,
				range = closureData.range,
				pk = range.pk, index = range.index, keyRange = range.keyRange,
				req = ORM._i5(),
				// IDBDatabase object of the user database
				userDatabase,
				databaseName = ORM._a3,
				schemaName = self._a3,
				data = [];
			
			var grabRecords = function( e ) {
				var cursor = e.target.result;
				if( cursor ) {
					data.push( cursor.value );
					cursor.continue();
				} else {
					// done
					userDatabase.close();
					closureData.callback.call( closureData.context, data );
				}
			};
			
			req.onsuccess = function( e ) {
				var db = e.target.result,
					transaction = db.transaction( [ schemaName ], MSQTA._ss.READ_ONLY );
					objectStore = transaction.objectStore( schemaName );
				
				// save the reference for the clsoe part
				userDatabase = db;
				
				if( pk ) {
					objectStore.openCursor( keyRange ).onsuccess = grabRecords;

				} else {
					objectStore.index( index ).openCursor( keyRange ).onsuccess = grabRecords;
				}
			};
		})( closureData );
	},
	/***************************************/
	put: function( datas, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			fields = this._a8, fieldName,
			pk = this._a7,
			schemaName = this._a3,
			data, i, l, k, m = fields.length,
			queryData;
		
		if( !( datas instanceof Array ) && typeof datas === 'object' ) {
			datas = [ datas ];
		}
		
		for( i = 0, l = datas.length; i < l; i++ ) {
			data = datas[i];
			for( k = 0; k < m; k++ ) {
				fieldName = fields[k];
				data[fieldName] = this._q( fieldName, data[fieldName] );
			}
			// lets the auto_increment works automatically if an id is not bee supplied
			if( data[pk] <= 0 ) {
				delete data[pk];
			}
		}

		queryData = {
			type: 'put',
			schema: schemaName,
			primaryKey: pk,
			data: datas,
			callback: g4,
			context: g5
		};
		
		if( ORM._b1 ) {
			return queryData;
		}
		
		ORM._i6( queryData );
	},
/***************************************/
	set: function( setDatas, g4, g5 ) {
		var ORM = this._a2,
			schemaName = this._a3,
			schemaFields = this._a4,
			databaseName = ORM._a3,		
			whereData, setData,
			cmpFields, newValues,
			fieldName, fieldValue,
			whereClause = {}, setClause = {},
			queries = [], i, l,
			queryData;
		
		if( !setDatas || typeof setDatas !== 'object' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !( setDatas instanceof Array ) ) {
			setDatas = [ setDatas ];
		}
		
		for( i = 0, l = setDatas.length; i < l; i++ ) {
			setData = setDatas[i];
			
			if( !setData.data || typeof setData.data !== 'object' || !Object.keys( setData.data ).length ) {
				throw Error( 'MSQTA-ORM!' );
			}
			
			if( setData.target ) {
				if( typeof setData.target !== 'object' || !Object.keys( setData.target ).length ) {
					throw Error( 'MSQTA-ORM!' );
				}
			// can be empty
			} else {
				setData.target = [];
			}
			
			cmpFields = setData.target;
			// check cmpFields validity
			for( fieldName in cmpFields ) {
				fieldValue = cmpFields[fieldName];
				parsedValue = this._q( fieldName, fieldValue );
				if( !parsedValue && parsedValue !== schemaFields[fieldName].bb ) {
					throw Error( 'MSQTA-ORM!' );
				}
				whereClause[fieldName] = parsedValue;
			}
			// whereClause can be empty
			
			newValues = setData.data;
			// check newValues validity
			for( fieldName in newValues ) {
				fieldValue = newValues[fieldName];
				parsedValue = this._q( fieldName, fieldValue );
				if( !parsedValue && parsedValue !== schemaFields[fieldName].bb ) {
					throw Error( 'MSQTA-ORM!' );
				}
				setClause[fieldName] = parsedValue;
			}
			
			queries.push( { data: setClause, target: whereClause } );
			
			setClause = {};
			whereClause = {};
		}
		
		queryData = {
			type: 'set',
			schema: schemaName,
			indexes: this._a5,
			primaryKey: this._a7,
			data: queries,
			callback: g4,
			context: g5	
		};
		
		if( ORM._b1 ) {
			return queryData;
		}
		
		ORM._i6( queryData );
	},
/***************************************/
	del: function( ids, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			pk = this._a7,
			schemaName = this._a3,
			id, parsedValue, 
			t, whereClause = [],
			i, l,
			queryData;
		
		if( !pk ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !ids ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !( ids instanceof Array ) ) {
			ids = [ ids ];
		}
		
		for( i = 0, l = ids.length; i < l; i++ ) {
			id = ids[i];
			parsedValue = this._q( pk, id );
			if( !parsedValue ) {
				throw Error( 'MSQTA-ORM!' );
			}
			t = {};
			t[pk] = parsedValue;
			whereClause.push( t );
		}
		
		queryData = {
			type: 'del',
			schema: schemaName,
			primaryKey: pk,
			data: whereClause,
			callback: g4,
			context: g5
		};
		
		// the only way that whereClause can be empty is that ids param must be a empty []
		if( ORM._b1 ) {
			return queryData;
		}
		
		ORM._i6( queryData );
	},
/***************************************/
	destroy: function( g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3;
		
		
		
		ORM._i6( {
			type: 'destroy',
			schema: schemaName,
			callback: g4,
			context: g5
		} );
	},
/***************************************/
	empty: function( g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3;

		
		
		ORM._i6( {
			type: 'empty',
			schema: schemaName,
			callback: g4,
			context: g5
		} );
	}
};
MSQTA._a2.b6 = {
	
	Schema: function( schemaDefinition ) {
		return MSQTA._ii.n( { 
			ORM: this.constructor._a2,
			schemaPrototype: MSQTA._a9.b6,
			schemaDefinition: schemaDefinition,
			implementation: 'webSQL',
			args: arguments
		} );
	},
	
	_b7: function() {
		// put in a close to handle various open at "the same time"
		(function( self ) {
			self._f4 = window.openDatabase( '__msqta__', 1, '', MSQTA._ii.ll );
			self._f4.transaction( function( tx ) {
				tx.executeSql( 'CREATE TABLE IF NOT EXISTS databases( id INTEGER PRIMARY KEY, name TEXT UNIQUE, schemas TEXT )' );
				tx.executeSql( 'SELECT * FROM databases WHERE name = "' + self._a3 + '"', [], function( tx, results ) {
					self._b8( results );
				} );
			} );
		})( this );
	},
	
	_b8: function( results ) {
		var rows = results.rows;
		// store here all the schemaKeepTrack definitions
		this._f5 = rows.length ? JSON.parse( rows.item( 0 ).schemas ) : {};
		
		// this holds queries to be run when a sql fails
		// this is used when the multiples queries are connected
		// but they cannot be runs all in a single transaction
		this._f6 = [];
		// this holds all the interal queries that are made when
		// a schema is initialized, these queries are more important
		// that this._uu in terms at the moment of execute the next g1
		this._f7 = [];
		
		this._f8 = window.openDatabase( this._a3, 1, '', MSQTA._ii.ll );

		this._zz.call( this.initContext, true );
		
		this._c1();
	},

	_b9: function( Schema ) {
		this._yy.push( Schema );
		if( !this._xx ) {
			this._xx = true;
			this._c1();
		}
	},
	
	_c1: function() {
		var self = this,
			databaseName = this._a3;
		
		if( this._yy.length ) {
			this._yy.shift()._d6();
			
		} else {
			this._c2();
		}
	},
	
	_c2: function() {
		this._xx = false;
	},
	
	_c3: function( callback, context, arg ) {
		var self = this,
			databaseName = this._a3,
			schemasDefinition = this._f5;
		
		
		this._f4.transaction( function( tx ) {
			tx.executeSql( 'REPLACE INTO databases( name, schemas ) VALUES( "' + databaseName + '", ' + "'" + JSON.stringify( schemasDefinition ) + "'" + ')', [], function() {
				// true for success
				callback.call( context, arg );
			} );
		} );
	},
	
	_c4: function( callback, context ) {
		this.destroy( callback, context );
	},
	
	_c5: function( Schema, queryData ) {
		var schemaName = Schema._a3;
		
		delete this._vv[schemaName];
		delete this._f5[schemaName];
		MSQTA._ii.k( Schema );
	
		this._c3( queryData.g4, queryData.g5, true );
	},
	
	/**
	* @context SQLTransaction
	*/
	_c6: function( error ) {
		
		// continue with more shit
		this._c9( false );
	},
/***************************************/
	_c7: function( queryData ) {
		var callback = queryData.g4,
			context = queryData.g5;
		
		if( callback && typeof callback !== 'function' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		// use default callback
		if( !callback ) {
			queryData.g4 = MSQTA._ii.b;
		}
		
		if( context && typeof context !== 'object' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		// use window as context
		if( !context ) {
			queryData.g5 = window;
		}

		// only allow a g1 per time
		if( this._b2 ) {
			if( queryData.h6 ) {
				this._f7.push( queryData );
			} else {
				this._uu.push( queryData );
			}
			return;
		}
		this._b2 = true;

		this._c8( queryData );
	},
	
	_c8: function( queryData ) {
		// save a refenrece for when the transaction is done
		this._f9 = queryData;

		// save a reference used in the success and error functions
		var self = this,
			// update an update at time is executed, so we need to keep tracking manually
			// the affected rows
			rowsAffected = 0,
			g1 = queryData.g1;
		
		if( !( g1 instanceof Array ) ) {
			g1 = [ g1 ];
		}
		
		// when you trigger multiple update queries, we need to keep
		// track the rows affected in the operation
		var a = queryData.g3 ? function( tx, results ) {
			rowsAffected += results.rowsAffected;
		} : MSQTA._ii.a;
		
		var success = function( tx, results ) {
			if( queryData.g3 ) {
				// sum the last executed one
				queryData.returnValue = results.rowsAffected + rowsAffected;
		
			} else if( queryData.g7 ) {
				queryData.returnValue = results.insertId;
			
			} else if( queryData.g6 ) {
				queryData.returnValue = results.rowsAffected;
			}
		
			self._c9( results );
		};
		
		var error = function( tx, error ) {
			self._c6( error );
		};
		
		this._f8.transaction( function( tx ) {			
			var q,
				l = g1.length;

			while( l-- ) {
				q = g1.shift();
				
				tx.executeSql( q, queryData.g2 ? queryData.g2.shift() : [], l ? a : success, error );
			}
		} );
	},
	
	/**
	* @context SQLTransaction
	*/
	_c9: function( results ) {
		queryData = this._f9;
		
		this._b2 = false;
		// comes from _c6()
		if( !results ) {
			queryData.returnValue = false;
		}
		
		// still more processing (only select clauses falls here)
		if( queryData.callback && queryData.context ) {
			// go to the original caller
			queryData.callback.call( queryData.context, results, queryData );
			
		// get back with the user
		} else {
			// only delete, update, insert quries falls here
			queryData.g4.call( queryData.g5, queryData.returnValue );
		}
		
		this._d1();
	},
	
	_d1: function() {
		if( !this._b2 ) {
			// more queries to be executed in the queue
			if( this._f7.length ) {
				this._c7( this._f7.shift() );
			} else if( this._uu.length && !this._xx ) {
				this._c7( this._uu.shift() );
			}
		}
	},
/***************************************/
/***************************************/
	batch: function( data, callback, context ) {
		var databaseName = this._a3,
			batchData;
		
		if( !( data instanceof Array ) || !data.length ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( typeof callback !== 'function' ) {
			callback = MSQTA._ii.b;
		}
		if( typeof context !== 'object' ) {
			context = window;
		}
		// agrup arguments for a better manipulation
		batchData = {
			data: data,
			callback: callback,
			context: context
		};
		
		if( this._b1 ) {
			this._ww.push( batchData );
			return;
		}
		// start batch mode, this means that the methods set, put and del
		// will not execute the g1, instead them will be return the querty string
		this._b1 = true;
		
		this._d2( batchData );
	},
	
	_d2: function( batchData ) {
		var data = batchData.data,
			typeValids = [ 'set', 'put', 'del' ],
			queryData, Schema, type,
			i = 0, l = data.length;
		
		for( ; i < l; i++ ) {
			queryData = data[i];
			Schema = queryData.schema;
			if( !( Schema instanceof MSQTA._a9 ) ) {
				throw Error( 'MSQTA-ORM!' );
			}
			type = queryData.type.toLowerCase();
			if( typeValids.indexOf( type ) === -1 ) {
				throw Error( 'MSQTA-ORM!' );
			}
			// save the queries
			this._uu.push( Schema[type]( queryData.data ) );
		}
		// the last one will the return point
		var t = this._uu[this._uu.length-1];
		t.g4 = batchData.callback;
		t.g5 = batchData.context;
		
		this._b1 = false;
		
		// exec the queries
		this._d1();

		// this happends when batch is called when another
		// batch process is running
		if( this._ww.length ) {
			this._d2( this._ww.shift() );
		}
	},
/***************************************/
/***************************************/
	destroy: function( callback, context ) {
		if( typeof callback !== 'function' ) {
			callback = MSQTA._ii.a;
		}
		
		
		
		callback.call( context || window, false );
	},
/***************************************/
/***************************************/
	_d3: function( g1 ) {
		this._f6.push( g1 );
		return this._f6.length-0;
	},
	
	_d4: function( id ) {
		this._f6.splice( id, 1 );
	}
};
MSQTA._a9.b6 = {

	_d5: function() {
		var schemaFields = this._a4,
			fieldData, fieldName,
			ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3,
			tableStruc = [], primaryKey = this._a7,
			attrs, indexesSQL = {}, isIndex, isUnique,
			createTableQuery,
			// used when forceDestroy property is setted
			dropTableQuery,
			schemaKeepTrack = {};
		
		for( fieldName in schemaFields ) {
			fieldData = schemaFields[fieldName];
			attrs = [];
			if( primaryKey === fieldName ) {
				attrs.push( 'PRIMARY KEY' );
				
			} else {
				isIndex = fieldData.index;
				isUnique = fieldData.unique;
				if( isIndex && isUnique ) {	
					// CREATE UNIQUE INDEX index_name ON table_name( column_name )
					indexesSQL[fieldName] = this._d7( schemaName, fieldName );
					
				} else if( isUnique ) {
					attrs.push( 'UNIQUE' );
				
				} else if( isIndex ) {
					// CREATE INDEX index_name ON table_name( column_name )
					indexesSQL[fieldName] = this._d8( schemaName, fieldName );
				}
			}
			
			// re set schema
			this._r( fieldName );
			// this is one is store in the testigo database to 
			// keep tracking future changes
			schemaKeepTrack[fieldName] = {
				type: fieldData.type,
				index: fieldData.index,
				unique: fieldData.unique
			};
			
			// for the CREATE TABLE g1 string
			tableStruc.push( fieldName + ' ' + schemaFields[fieldName].gg + ( attrs.length ? ' ' + attrs.join( ' ' ) : '' ) );
		}
		
		createTableQuery = 'CREATE TABLE "' + schemaName + '" ( ' + tableStruc.join( ', ' ) + ' )';
		// save a reference for latter usage
		this._g8 = createTableQuery;
		// this used to detect schema changes
		this._b3 = schemaKeepTrack;
		// the indexes
		this._g9 = indexesSQL;
		// this will ppoulated (if there the case) in this._d9()
		this._h1 = [];
		
		ORM._b9( this );
	},
	
	_d6: function() {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3,
			
			createTableQuery = this._g8,
			dropTableQuery,
		
			registeredSchemaDefinition, currentSchemaDefinition;
		
		if( this.forceDestroy ) {
			this._h5 = true;
			
			dropTableQuery = '--MSQTA-ORM: "forceDestroy" flag detected: destroying the "' + schemaName + '" schema from the "' + databaseName + '" database, then it will recreate again\n\tDROP TABLE IF EXISTS ' + schemaName;
		
			ORM._c7( { g1: [ dropTableQuery, createTableQuery ], context: this, callback: this._e6, h6: true } );
		
		// check for schema changes
		} else {
			
			currentSchemaDefinition = { fields: this._b3, primaryKey: this._a7 };
			registeredSchemaDefinition = ORM._f5[schemaName];
			// a new schema to be created
			if( !registeredSchemaDefinition ) {
				// save a reference
				ORM._f5[schemaName] = currentSchemaDefinition;
				this._a2._c3( this._e1, this );

			// check for schema changes
			} else {
				this._d9( registeredSchemaDefinition, currentSchemaDefinition );
			}
		}
	},
	
	_d7: function( schemaName, fieldName ) {
		return 'CREATE UNIQUE INDEX ' + schemaName + '_' + fieldName + ' ON ' + schemaName + ' ( ' + fieldName + ' )';
	},
	
	_d8: function( schemaName, fieldName ) {
		return  'CREATE INDEX ' + schemaName + '_' + fieldName + ' ON ' + schemaName + ' ( ' + fieldName + ' )';
	},
	
	_d9: function( registeredSchemaDefinition, currentSchemaDefinition ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3,
			isNewSchema = false,
			registeredFieldsData = registeredSchemaDefinition.fields,
			currentFieldsData = currentSchemaDefinition.fields,
			registeredFieldData, currentFieldData, fieldName,
			registeredIndexesSQL = {},
			currentIndexesSQL = this._g9;
		
		for( fieldName in registeredFieldsData ) {
			registeredFieldData = registeredFieldsData[fieldName];
			currentFieldData = currentFieldsData[fieldName];
			
			// the field has been deleted
			if( !currentFieldData ||
			// type field has changed
			registeredFieldData.type !== currentFieldData.type ) {
				isNewSchema = true;
				break;
			}
			
			// in the meantime, get the index of the regstered
			if( registeredFieldData.index && registeredFieldData.unique ) {
				registeredIndexesSQL[fieldName] = this._d7( schemaName, fieldName );
			} else if( registeredFieldData.index ) {
				registeredIndexesSQL[fieldName] = this._d8( schemaName, fieldName );
			}
			
		}
		
		var registeredPK = registeredSchemaDefinition.primaryKey,
			currentPK = currentSchemaDefinition.primaryKey;
		
		if( !isNewSchema ) {
			// chaging/droping the primaryKey required a new schema too
			if( ( registeredPK && ( !currentPK || registeredPK !== currentPK ) ) ||
			// previoulsy there is not a primary key, but now yes
			( !registeredPK && currentPK ) ) {
				isNewSchema = true;
			}
		}
		
		// we must to update the table strcutre
		// the update schema procecss drop the current schema and the create it again
		if( isNewSchema ) {
			
			// start the damn updateing process
			ORM._f5[schemaName] = currentSchemaDefinition;
			this._a2._c3( this._e2, this );
		
		// check for indexes changes
		} else {
			var registeredIndexQuery, 
				currentIndexQuery,
				indexesToDelete = [];

			for( fieldName in registeredIndexesSQL ) {
				registeredIndexQuery = registeredIndexesSQL[fieldName];
				currentIndexQuery = currentIndexesSQL[fieldName];
				// the index has been dropped
				if( ( !currentIndexQuery ) ||
				// still the index exists but now has a different compisition
				( currentIndexQuery && registeredIndexQuery !== currentIndexQuery ) ) {
					indexesToDelete.push( fieldName );
				}
			}
			
			if( indexesToDelete.length ) {
				this._h1 = indexesToDelete;
				
				
				ORM._f5[schemaName] = currentSchemaDefinition;
				this._a2._c3( this._e6, this );
			
			} else {
				
				this._e8();
			}
		}
	},
	
	_e1: function() {
		var ORM = this._a2,
			schemaName = this._a3,
			databaseName = ORM._a3,
			createTableQuery = this._g8;
		
		
		
		// create the new table
		ORM._c7( { g1: [ createTableQuery ], context: this, callback: this._e6, h6: true } );
	},
	
	_e2: function() {
		var ORM = this._a2,
			newSchema = this._g8,
			schemaName = this._a3,
			tempschemaName = schemaName + (+new Date()),
			// based on the newSchema we need to create in a form a backup, and the end we just will rename it
			createTempTableQuery = newSchema.replace( 'CREATE TABLE "' + schemaName + '"', 'CREATE TABLE "' + tempschemaName + '"' );

		// prepare the offset for the step2
		this._h2 = 0;
		// and tempschemaName too
		this._h3 = tempschemaName;
		
		
		
		ORM._c7( { g1: [ createTempTableQuery ], context: this, callback: this._e3, h6: true } );
	},
	
	_e3: function() {
		var ORM = this._a2,
			schemaName = this._a3,
			tempschemaName = this._h3,
			offset = this._h2,
			selectQuery,
			// this is already the new schema
			schemaFields = this._a4;
		
		// this is case that any error ocurr here we can restore, this is because
		// this porces is not enclosed in a transaction
		this._h4 = ORM._d3( 'DROP TABLE ' + tempschemaName );
		
		// get all the records from the table with the oldSchema
		selectQuery = 'SELECT * FROM ' + schemaName + ' LIMIT ' + offset + ', 500';		
		
	
		ORM._c7( { g1: [ selectQuery ], context: this, callback: this._e4, h6: true } );
	},
	
	_e4: function( results ) {
		var ORM = this._a2,
			// this is already the new schema
			schemaFields = this._a4,
			schemaName = this._a3,
			tempschemaName = this._h3,
			rows = results.rows,
			rowData, fieldName,
			schemaColData,
			insertQueryCols = [],
			insertQueryValues = [], newValues = [],
			insertQueries = [],
			i, l;
		
		if( !results ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		// the old schema is empty
		if( !rows.length ) {
			
			this._e5();
			return;
		}
		
		// prepare the cols in the insert g1
		rowData = rows.item( 0 );
		for( fieldName in rowData ) {
			if( schemaFields[fieldName] ) {
				insertQueryCols.push( fieldName );
			}
		}
		// now check the defaults values for the new rows (rows that in the current does not exists)
		for( fieldName in schemaFields ) {
			schemaColData = schemaFields[fieldName];
			if( insertQueryCols.indexOf( fieldName ) === -1 ) {
				insertQueryCols.push( fieldName );
				newValues.push( schemaColData.bb );
			}
		}
		
		for( i = 0, l = rows.length; i < l; i++ ) {
			rowData = rows.item( i );
			for( fieldName in rowData ) {
				// get how this fieldName has to been in the new schema
				schemaColData = schemaFields[fieldName];
				if( schemaColData ) {
					if( schemaColData.hh ) {
						insertQueryValues.push( "'" + rowData[fieldName] + "'" );
					} else {
						insertQueryValues.push( schemaColData.cc( rowData[fieldName], schemaColData.bb ) );
					}
				}
			}
			
			// make a row insert values
			insertQueries.push( 'INSERT INTO ' + tempschemaName + ' ( ' + insertQueryCols.join( ', ' ) + ' ) VALUES ( ' + insertQueryValues.concat( newValues ).join( ', ' ) + ' )' );
			insertQueryValues = [];
		}
		
		
		
		// get for more records
		if( l === 500 ) {
			this._h2 += 500;
			ORM._c7( { g1: insertQueries, context: this, callback: this._e3, h6: true } );
		} else {
			ORM._c7( { g1: insertQueries, context: this, callback: this._e5, h6: true } );
		}
	},
	
	_e5: function() {
		var ORM = this._a2,
			schemaName = this._a3,
			dropQuery = 'DROP TABLE '  + schemaName,
			tempschemaName = this._h3,
			renameQuery = 'ALTER TABLE ' + tempschemaName + ' RENAME TO ' + schemaName;
		
		
		
		// i need this, because when you drop a table, automatcally its index are dropped aswell,
		// to avoid this process in _e6
		this._h5 = true;
		
		ORM._c7( { g1: [ dropQuery, renameQuery ], context: this, callback: this._e6, h6: true } );
	},
	
	_e6: function() {
		var ORM = this._a2,
			databaseName = ORM._a3,
			indexQueries = [],
			indexesToDelete = this._h1,
			fieldName, indexesSQL = this._g9;
		
		
		
		// not need to drop an index is the referenced table has been dropped
		if( !this._h5 ) {
			while( indexesToDelete.length ) {
				indexQueries.push( 'DROP INDEX ' + databaseName + '_' + indexesToDelete.shift() );
			}
		} else {
			// no more need it
			delete this._h5;
		}
		
		// DROP INDEX queries + CREATE INDEX queries
		for( fieldName in indexesSQL ) {
			indexQueries.push( indexesSQL[fieldName] );
		}
		
		if( indexQueries.length ) {
			ORM._c7( { g1: indexQueries, context: this, callback: this._e7, h6: true } );
			
		} else {
			this._e7();
		}
	},
	
	_e7: function() {
		var ORM = this._a2;
		

		// clean all
		ORM._d4( this._h4 );
		delete this._h3;
		delete this._h2;
		delete this._h4;
		delete this._h1;
		
		if( this.forceEmpty ) {
			this._e9();
		} else {
			this._e8();
		}
	},
	
	_e8: function() {
		var ORM = this._a2;
		// clean more shit
		delete this._g8;
		delete this._g9;
		
		this._zz.call( this._a1, true );
		delete this._zz;
		delete this._a1;
		
		// continue
		ORM._c1();
	},
	
	_e9: function() {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaName = this._a3,
			emptyQuery = '--MSQTA-ORM: "forceEmpty" flag detected: emptying the "' + schemaName + '" schema from the "' + databaseName + '" database\n\tDELETE FROM ' + schemaName;
			
		ORM._c7( { g1: [ emptyQuery ], context: this, callback: this._e8, h6: true } );
	},
/***************************************/
	get: function( searchValue, g4, g5 ) {
		var ORM = this._a2,
			schemaFields = this._a4,
			fieldName,
			databaseName = ORM._a3,
			schemaName = this._a3,
			selectQuery,
			whereClause = [], values = [];
		
		if( !searchValue ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		for( fieldName in schemaFields ) {
			whereClause.push( fieldName + ' = ?' );
			values.push( this._q( fieldName, searchValue ) );
		}
		
		selectQuery = 'SELECT * FROM ' + schemaName + ' WHERE ' + whereClause.join( ' OR ' );
		
		ORM._c7( { 
			g1: selectQuery, 
			g2: [ values ],
			context: this,
			callback: this._f2, 
			g4: g4, 
			g5: g5 
		} );
	},
	
	getByCallback: function( filterCallback, g4, g5 ) {
		var ORM = this._a2,
			schemaFields = this._a4,
			fieldName,
			schemaName = this._a3,
			selectQuery;

		if( typeof filterCallback !== 'function' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		selectQuery = 'SELECT * FROM ' + schemaName;
		
		ORM._c7( { 
			g1: selectQuery, 
			context: this, 
			callback: this._f1, 
			g4: g4, 
			g5: g5,
			filterCallback: filterCallback
		} );
	},
	
	_f1: function( results, queryData ) {
		var schemaFields = this._a4,
			rows = results.rows,
			i = 0, l = rows.length,
			row, fieldName,
			filterCallback = queryData.filterCallback,
			t, data = [];
		
		for( ; i < l; i++ ) {
			row = rows.item( i );
			// copy each row to t, this is beacuse the results set is inumtable
			t = {};
			for( fieldName in row ) {
				t[fieldName] = schemaFields[fieldName].dd( row[fieldName] );
			}
			if( filterCallback( t ) ) {
				data.push( t );
			}
		}
		
		// comeback
		queryData.g4.call( queryData.g5, data );
	},
	
	getByIndex: function( fieldName, searchValue, g4, g5 ) {
		var ORM = this._a2,	
			databaseName = ORM._a3,
			schemaName = this._a3,
			selectQuery, whereClause = [], values = [],
			fieldValue, parsedValue, i, l;
		
		if( this._a7 !== fieldName ) {
			if( this._a5.indexOf( fieldName ) === -1 ) {
				throw Error( 'MSQTA-ORM!' );
			}
		}
		
		if( !searchValue ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !( searchValue instanceof Array ) ) {
			searchValue = [ searchValue ];
		}
		
		for( i = 0, l = searchValue.length; i < l; i++ ) {
			fieldValue = searchValue[i];
			parsedValue = this._q( fieldName, fieldValue );
			whereClause.push( fieldName + ' = ?' );
			values.push( parsedValue );
		}
		
		// whereClause can be empty

		selectQuery = 'SELECT * FROM ' + schemaName + ( whereClause.length ? ' WHERE ' + whereClause.join( ' OR ' ) : '' );

		ORM._c7( { 
			g1: selectQuery,
			g2: [ values ],
			context: this, 
			callback: this._f2, 
			g4: g4, 
			g5: g5
		} );
	},
	
	getByIndexWithRange: function( fieldName, comparator, g4, g5 ) {
		var ORM = this._a2,	
			databaseName = ORM._a3,
			schemaName = this._a3,
			schemaFields = this._a4,
			validOperators = /^(?:>|<|>=|<=|=)$/, operator,
			whereClause = [], fieldValue, parsedValue, values = [],
			selectQuery;
		
		if( this._a7 !== fieldName ) {
			if( this._a5.indexOf( fieldName ) === -1 ) {
				throw Error( 'MSQTA-ORM!' );
			}
		}
		
		for( operator in comparator ) {
			if( !validOperators.test( operator ) ) {
				throw Error( 'MSQTA-ORM!' );
			}
			fieldValue = comparator[operator];
			parsedValue = this._q( fieldName, fieldValue );
			if( !parsedValue && parsedValue !== schemaFields[fieldName].bb ) {
				throw Error( 'MSQTA-ORM!' );
			}
			whereClause.push( fieldName + ' ' + operator + ' ?' );
			values.push( parsedValue );
		}
		
		if( !whereClause.length ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		selectQuery = 'SELECT * FROM ' + schemaName + ' WHERE ' + whereClause.join( ' AND ' );
		
		ORM._c7( { 
			g1: selectQuery,
			g2: [ values ],
			context: this, 
			callback: this._f2, 
			g4: g4, 
			g5: g5
		} );
	},

	getAll: function( g4, g5 ) {
		var ORM = this._a2,
			schemaName = this._a3,
			selectAllQuery = 'SELECT * FROM ' + schemaName;

		ORM._c7( {
			g1: selectAllQuery, 
			context: this, 
			callback: this._f2, 
			g4: g4, 
			g5: g5
		} );
	},
	
	getWithLike: function( fields, likeData, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			schemaFields = this._a4,
			schemaName = this._a3,
			i, l, fieldName,
			likeType, searchValue, values = [],
			selectQueryWithLike, whereClause = [];
		
		if( typeof likeData !== 'object' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		likeType = Object.keys( likeData )[0];
		searchValue = likeData[likeType];
		if( !likeType || !searchValue ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( likeType === 'both' ) {
			searchValue = '%' + searchValue + '%';
		} else if( likeType === 'start' ) {
			searchValue = searchValue + '%';
		} else if( likeType === 'end' ) {
			searchValue = '%' + searchValue;
		}
		
		if( !( fields instanceof Array ) ) {
			fields = [ fields ];
		}
		for( i = 0, l = fields.length; i < l; i++ ) {
			fieldName = fields[i];
			if( !schemaFields[fieldName] ) {
				throw Error( 'MSQTA-ORM!' );
			}
			whereClause.push( fieldName + ' LIKE ?' );
			values.push( searchValue );
		}
		selectQueryWithLike = 'SELECT * FROM ' + schemaName + ' WHERE ' + whereClause.join( ' OR ' );

		ORM._c7( { 
			g1: selectQueryWithLike,
			g2: [ values ],
			context: this, 
			callback: this._f2, 
			g4: g4, 
			g5: g5 
		} );
	},

	_f2: function( results, queryData ) {
		var schemaFields = this._a4,
			rows = results.rows,
			i = 0, l = rows.length,
			row, fieldName,
			t, data = [];
		
		for( ; i < l; i++ ) {
			row = rows.item( i );
			t = {};
			// copy each row to t, this is beacuse the results set is inumtable
			for( fieldName in row ) {
				t[fieldName] = schemaFields[fieldName].dd( row[fieldName] );
			}
			data.push( t );
		}
		
		queryData.g4.call( queryData.g5, data );
	},
/***************************************/
	put: function( datas, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			fields = this._a8, fieldName,
			schemaName = this._a3,
			insertQueryCols,
			insertQueryValues = [], values,
			insertQueryValuesTokens,
			insertQueries = [],
			data, i, l, k, m = fields.length,
			queryData;
		
		if( !( datas instanceof Array ) && typeof datas === 'object' ) {
			datas = [ datas ];
		}
		
		for( i = 0, l = datas.length; i < l; i++ ) {
			data = datas[i];
			insertQueryCols = [];
			values = [];
			insertQueryValuesTokens = [];
			for( k = 0; k < m; k++ ) {
				fieldName = fields[k];
				insertQueryCols.push( fieldName );
				values.push( this._q( fieldName, data[fieldName] ) );
				insertQueryValuesTokens.push( '?' );
			}
			insertQueryValues.push( values );
			insertQueries.push( 'INSERT INTO ' + schemaName + ' ( ' + insertQueryCols.join( ', ' ) + ' ) ' + 'VALUES ( ' + insertQueryValuesTokens.join( ' , ' ) + ' )' );
		}
		
		queryData = { 
			g1: insertQueries,
			g2: insertQueryValues,
			g4: g4, 
			g5: g5,
			// need it to get the lastID
			g7: true
		};
		
		if( ORM._b1 ) {
			return queryData;
		}
		
		ORM._c7( queryData );
	},	
/***************************************/
	/*
	set( {
		data: { comments: 'gay' }
	} );
	set( {
		data: { comments: 'gay' },
		target: { id: 1 } 
	} );
	set( [ {
		data: { comments: 'trolazo' },
		target: { id: 1 }
	} ] );
	*/
	set: function( setDatas, g4, g5 ) {
		var ORM = this._a2,
			schemaName = this._a3,
			databaseName = ORM._a3,
			schemaFields = this._a4,
			whereData, setData,
			cmpFields, newValues,
			fieldName, fieldValue,
			whereClause,
			setClause,
			values = [], t,
			queries = [], i, l,
			queryData;
		
		if( !setDatas || typeof setDatas !== 'object' ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !( setDatas instanceof Array ) ) {
			setDatas = [ setDatas ];
		}
		
		for( i = 0, l = setDatas.length; i < l; i++ ) {
			setData = setDatas[i];
			
			t = [];
			setClause = [];
			whereClause = [];
			
			if( !setData.data || typeof setData.data !== 'object' || !Object.keys( setData.data ).length ) {
				throw Error( 'MSQTA-ORM!' );
			}
			
			if( setData.target ) {
				if( typeof setData.target !== 'object' || !Object.keys( setData.target ).length ) {
					throw Error( 'MSQTA-ORM!' );
				}	
			// can be empty
			} else {
				setData.target = [];
			}
			
			newValues = setData.data;
			// check newValues validity
			for( fieldName in newValues ) {
				fieldValue = newValues[fieldName];
				parsedValue = this._q( fieldName, fieldValue );
				if( !parsedValue && parsedValue !== schemaFields[fieldName].bb ) {
					throw Error( 'MSQTA-ORM!' );
				}
				setClause.push( fieldName + ' = ?' );
				t.push( parsedValue );
			}
			
			cmpFields = setData.target;
			// check cmpFields validity
			for( fieldName in cmpFields ) {
				fieldValue = cmpFields[fieldName];
				parsedValue = this._q( fieldName, fieldValue );
				if( !parsedValue && parsedValue !== schemaFields[fieldName].bb ) {
					throw Error( 'MSQTA-ORM!' );
				}
				whereClause.push( fieldName + ' = ?' );
				t.push( parsedValue );
			}
			// whereClause can be empty
			
			queries.push( 'UPDATE ' + schemaName + ' SET ' + setClause.join( ', ' ) + ( whereClause.length ? ' WHERE ' + whereClause.join( ' AND ' ) : '' ) );
			values.push( t );
		}
		
		queryData = { 
			g1: queries,
			g2: values,
			g3: true,
			g4: g4, 
			g5: g5 
		};
		
		if( ORM._b1 ) {
			return queryData;
		}

		ORM._c7( queryData );
	},
/***************************************/
	del: function( ids, g4, g5 ) {
		var ORM = this._a2,
			databaseName = ORM._a3,
			pk = this._a7,
			schemaName = this._a3,
			id, parsedValue, 
			deleteQuery, whereClause = [],
			i, l,
			queryData;
		
		if( !pk ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !ids ) {
			throw Error( 'MSQTA-ORM!' );
		}
		
		if( !( ids instanceof Array ) ) {
			ids = [ ids ];
		}
		
		for( i = 0, l = ids.length; i < l; i++ ) {
			id = ids[i];
			parsedValue = this._q( pk, id );
			if( !parsedValue ) {
				throw Error( 'MSQTA-ORM!' );
			}
			
			whereClause.push( pk + ' = ' + parsedValue );
		}
		
		// the only way that whereClause can be empty is that ids param must be a empty []
		
		deleteQuery = 'DELETE FROM ' + schemaName + ( whereClause.length ? ' WHERE ' + whereClause.join( ' OR ' ) : '' );
		
		queryData = { 
			g1: deleteQuery,
			g6: true,
			g4: g4, 
			g5: g5 
		};
		
		if( ORM._b1 ) {
			return queryData;
		}
		
		ORM._c7( queryData );
	},
/***************************************/
	destroy: function( g4, g5 ) {
		var ORM = this._a2,
			schemaName = this._a3,
			dropQuery = 'DROP TABLE ' + schemaName;
		
		ORM._c7( {
			callback: this._f3,
			context: this,
			g1: dropQuery, 
			g4: g4, 
			g5: g5 
		} );
	},
	
	_f3: function( results, queryData ) {
		var ORM = this._a2;
		
		if( results ) {
			ORM._c5( this, queryData );
		}
	},
/***************************************/
	empty: function( g4, g5 ) {
		var ORM = this._a2,
			schemaName = this._a3,
			deleteQuery = 'DELETE FROM ' + schemaName;

		ORM._c7( { 
			g1: deleteQuery,
			g6: true,
			g4: g4, 
			g5: g5 
		} );
	}
};

window.MSQTA = MSQTA;
})( window );